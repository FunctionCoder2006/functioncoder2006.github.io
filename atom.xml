<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://functioncoder2006.github.io</id>
    <title>JeffZhao&apos;s Blog</title>
    <updated>2022-01-02T07:05:02.550Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://functioncoder2006.github.io"/>
    <link rel="self" href="https://functioncoder2006.github.io/atom.xml"/>
    <subtitle>我醉欲眠卿且去，明朝有意抱题来</subtitle>
    <logo>https://functioncoder2006.github.io/images/avatar.png</logo>
    <icon>https://functioncoder2006.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, JeffZhao&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[超快速排序]]></title>
        <id>https://functioncoder2006.github.io/post/chao-kuai-su-pai-xu/</id>
        <link href="https://functioncoder2006.github.io/post/chao-kuai-su-pai-xu/">
        </link>
        <updated>2022-01-01T10:32:27.000Z</updated>
        <content type="html"><![CDATA[<p>首先我们需要知道几个性质：</p>
<p><strong>任何一个无序的序列都可以通过邻项交换的手段变成一个有序的序列</strong></p>
<p><strong>邻项交换相当于进行一次冒泡排序，逆序对数会减 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></strong></p>
<p><strong>如果我们想让结果变成有序的，那么我们的逆序对数一定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></strong></p>
<p>因为每一个数互不相等，因此，当此时为无序序列时，一定可以找到两个相邻的并且这两个数为逆序对，然后通过交换使得逆序对数 减 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>那么，答案也就是逆序对数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 5e5 + 10;

int n , a[N] , b[N];
long long ans;

void merge(int l , int r){
    if(l == r)return;
    int mid = (l + r) &gt;&gt; 1;
    merge(l , mid) , merge(mid + 1 , r);
    int i = l , j = mid + 1;
    for(int k = l ; k &lt;= r ; ++ k){
        if(j &gt; r || (i &lt;= mid &amp;&amp; a[i] &lt;= a[j]))
            b[k] = a[i] , ++ i;
        else b[k] = a[j] , ++ j , ans += mid - i + 1;
    } 
    for(int k = l ; k &lt;= r ; ++ k){
        a[k] = b[k];
    }
    return;
}

int main(void){

    while(1){    
        ans = 0;
        scanf(&quot;%d&quot; , &amp;n);
        if(n == 0)break;
        for(int i = 1 ; i &lt;= n ; ++ i){
            scanf(&quot;%d&quot; , &amp;a[i]);
        }
        memset(b , 0 , sizeof(b));
        merge(1 , n);
        printf(&quot;%lld\n&quot; , ans);
    }

    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇怪的汉诺塔]]></title>
        <id>https://functioncoder2006.github.io/post/qi-guai-de-han-nuo-ta/</id>
        <link href="https://functioncoder2006.github.io/post/qi-guai-de-han-nuo-ta/">
        </link>
        <updated>2022-01-01T06:27:14.000Z</updated>
        <content type="html"><![CDATA[<p>首先我们思考三个汉诺塔是怎样的</p>
<p>我们发现，如果我们想找到一种<strong>合法</strong>方案，<strong>我们就必须把最下方的圆盘上面所有的圆盘拿开并且将最下方的圆盘放到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 柱</strong></p>
<p>而拿开的柱子放到哪里呢？只能放到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 柱，因为放到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 柱以后肯定还要再拿下来，不优；放到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 柱肯定还要再拿走，也不优</p>
<p>而放到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 柱的话，我们只能按照题目要求，大圆盘放在小圆盘下面</p>
<p>因此，我们需要知道将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个柱子移动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 柱的最少步骤</p>
<p>而我们又发现，此时状态可以<strong>等效成将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个盘子挪动到指定位置的最少步骤</strong></p>
<p>因为最大的盘子上显然可以放任意一个盘子，我们可以假装它是不存在的</p>
<p>我们发现，在<strong>我们逐步地理性分析之下，我们将原问题成功分解成规模更小的子问题</strong></p>
<p>然后我们考虑四个汉诺塔是怎样的</p>
<p>还是，我们考虑将最大的盘子挪动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 柱。在此之前，我们首先要将剩下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个盘子挪动到剩下两个盘子。然后我们一次考虑将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个盘子再分，然后我们考虑将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个盘子挪动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 柱，<strong>但是不能挪动到两个柱子，因为这样的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - 1 - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个柱子就没有活动的空间了</strong>。</p>
<p>然后我们将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - 1 - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个盘子挪动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 柱</p>
<p>其实我们很快就会发现，我们将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个盘子挪动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 柱就可以等效成有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个盘子，四个汉诺塔，求最小移动次数，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - 1 - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个盘子挪动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 柱就可以等效成有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n - 1 - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个盘子，三个汉诺塔，求最小移动次数</p>
<p>然后我们的问题就迎刃而解了</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 30;

int n = 12;
long long g[N] , f[N];

int main(void){

    memset(f , 0x3f , sizeof(f));

    f[1] = g[1] = 1;

    for(int i = 2 ; i &lt;= n ; ++ i){
        g[i] = g[i - 1] * 2 + 1;
    }

    for(int i = 2 ; i &lt;= n ; ++ i){
        for(int j = 1 ; j &lt; i ; ++ j){
            f[i] = min(f[i] , 2 * f[j] + g[i - j]);
        }
    }
    for(int i = 1 ; i &lt;= n ; ++ i){
        cout &lt;&lt; f[i] &lt;&lt; endl;
    }

    return 0;

}
</code></pre>
<p>其实你会发现，整个过程中，<strong>需要我们格外注意此时的状态可以等效成什么</strong>，如果我们可以发现，那么原问题就得以分解</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[费解的开关]]></title>
        <id>https://functioncoder2006.github.io/post/fei-jie-de-kai-guan/</id>
        <link href="https://functioncoder2006.github.io/post/fei-jie-de-kai-guan/">
        </link>
        <updated>2022-01-01T06:09:21.000Z</updated>
        <content type="html"><![CDATA[<p>看到这道题，首先联想的是树上的灯那道题</p>
<p>因此我们很容易得到两个性质：</p>
<ul>
<li><strong>点灯顺序不影响最终结果</strong></li>
<li><strong>每一个灯最多点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 下</strong></li>
</ul>
<p>因为每点一下灯，就是对周围的数进行异或运算，显然与顺序无关，最终都是异或那么多次。考虑异或的一个性质，<strong>异或两次等于什么都没有做</strong>或者说是 <strong>异或的奇偶性</strong>。因此每一个灯最多点一下</p>
<p>因此，<strong>既然顺序不影响最终结果，那么我们不妨一行一行地考虑</strong></p>
<p>然后第三个性质是非常妙的</p>
<p>我们发现，<strong>如果我们固定住第一行的状态并且要让所有的灯点亮，我们最多只有一种方案</strong></p>
<p>因为我们考虑，如果这一行进行点击后并没有全部变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，那么只能由下一行的点击来点亮。又因为一个灯的点击只影响上下左右和它自己。因此，我们如果想点亮这个灯的话，只能由它的正下方的灯来点击</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

using namespace std;

int q , ans , h[10000] , a[10][10] , s[10][10];
char str[10][10];

inline int lowbit(int x){
    return x &amp; (-x);
}

inline int solve(int state){
    int cnt = 0;
    while(state){
        int x = h[lowbit(state)] + 1;
        s[2][x] ^= 1 , s[1][x - 1] ^= 1 , s[1][x + 1] ^= 1 , s[1][x] ^= 1;
        state -= lowbit(state);
        ++ cnt;
    }
    for(int i = 2 ; i &lt;= 5 ; ++ i){
        for(int j = 1 ; j &lt;= 5 ; ++ j){
            if(s[i - 1][j] == 0){
                s[i][j] ^= 1 , s[i - 1][j] ^= 1 , s[i + 1][j] ^= 1 , s[i][j - 1] ^= 1 , s[i][j + 1] ^= 1;
                ++ cnt;
            }
        }
    }
    for(int j = 1 ; j &lt;= 5 ; ++ j){
        if(s[5][j] == 0)
            return (1 &lt;&lt; 30);
    }
    return cnt;
}

int main(void){

    scanf(&quot;%d&quot; , &amp;q);

    for(int i = 0 ; i &lt;= 6 ; ++ i){
        h[1 &lt;&lt; i] = i;
    }

    while(q -- ){
        ans = (1 &lt;&lt; 30);
        for(int i = 1 ; i &lt;= 5 ; ++ i){
            scanf(&quot;%s&quot; , str[i] + 1);
            for(int j = 1 ; j &lt;= 5 ; ++ j){
                a[i][j] = str[i][j] - '0';
            }
        }
        for(int i = 0 ; i &lt; (1 &lt;&lt; 5) ; ++ i){
            memcpy(s , a , sizeof(s));
            ans = min(ans , solve(i));
        }
        if(ans &gt; 6){
            puts(&quot;-1&quot;);
        }
        else printf(&quot;%d\n&quot; , ans);
    }

    return 0;

}

</code></pre>
<p>还有就是注意，<strong>不要将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup><msup><mn>0</mn><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">&#x27;0&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 混淆了</strong>，感觉自己挺愚蠢的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[起床困难综合症]]></title>
        <id>https://functioncoder2006.github.io/post/qi-chuang-kun-nan-zong-he-zheng/</id>
        <link href="https://functioncoder2006.github.io/post/qi-chuang-kun-nan-zong-he-zheng/">
        </link>
        <updated>2022-01-01T05:56:24.000Z</updated>
        <content type="html"><![CDATA[<p>其实这道题还是比较简单的</p>
<p>非常直观地，我们可以想到枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">i∈[0 , m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span>，求出其经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 扇门最后的值，然后取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span></span></span></span></p>
<p>然后我们考虑优化</p>
<p>非常显然的是，这是一道二进制题</p>
<p>而题目中给的这些二进制运算<strong>对于每一个二进制位是互不干涉的</strong>。也就是我可以分别考虑每一个二进制位</p>
<p>一个常见的二进制贪心思想：<strong>尽量让高位为1</strong></p>
<p>因此，我们考虑从高位开始，尝试着这一位填 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 更优还是填 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 更优</p>
<p>如果我们发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 一样优的话，我们选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，<strong>因为这样会给后几位留出更多的可能</strong></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 1e5 + 10;

int n , m , a[N] , sum , ans;
char opt[N][10];

int main(void){

    scanf(&quot;%d%d&quot; , &amp;n , &amp;m);

    for(int i = 1 ; i &lt;= n ; ++ i){
        scanf(&quot;%s&quot; , opt[i]);
        scanf(&quot;%d&quot; , &amp;a[i]);
    }

    for(int k = 30 ; k &gt;= 0 ; -- k){
        int s0 = 0 , s1 = 1;
        for(int i = 1 ; i &lt;= n ; ++ i){
            if(opt[i][0] == 'O'){
                s0 |= (1 &amp; (a[i] &gt;&gt; k));
                s1 |= (1 &amp; (a[i] &gt;&gt; k));
            }
            if(opt[i][0] == 'X'){
                s0 ^= (1 &amp; (a[i] &gt;&gt; k));
                s1 ^= (1 &amp; (a[i] &gt;&gt; k));
            }
            if(opt[i][0] == 'A'){
                s0 &amp;= (1 &amp; (a[i] &gt;&gt; k));
                s1 &amp;= (1 &amp; (a[i] &gt;&gt; k));
            }
        }
        if(s0 &gt; s1){
            ans += (1 &lt;&lt; k);
        }
        else if(s1 &gt; s0){
            if(sum + (1 &lt;&lt; k) &lt;= m){
                ans += (1 &lt;&lt; k);
                sum += (1 &lt;&lt; k);
            }
        }
        else {
            ans += s0 * (1 &lt;&lt; k);
        }
    }

    printf(&quot;%d&quot; , ans);
    
    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编辑器]]></title>
        <id>https://functioncoder2006.github.io/post/bian-ji-qi/</id>
        <link href="https://functioncoder2006.github.io/post/bian-ji-qi/">
        </link>
        <updated>2021-12-31T08:36:42.000Z</updated>
        <content type="html"><![CDATA[<p>这道题是一道对顶栈裸题</p>
<p>因为每一次都在光标处进行操作并且每一次最多移动一个数</p>
<p>其实，这道题凭感觉我们应该可以想到对顶栈的做法</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;

using namespace std;

const int N = 1e6 + 10;

int q , x;
char opt[2];
int s1[N] , s2[N] , cnt1 , cnt2 , sum[N] , f[N];

int main(void){

    scanf(&quot;%d&quot; , &amp;q);
    
    memset(f , ~0x3f , sizeof(f));
    
    sum[0] = 0;

    while(q -- ){
        scanf(&quot;%s&quot; , opt);
        if(opt[0] == 'I'){
            scanf(&quot;%d&quot; , &amp;x);
            s1[++ cnt1] = x;
            sum[cnt1] = sum[cnt1 - 1] + x;
            f[cnt1] = max(f[cnt1 - 1] , sum[cnt1]);
        }
        if(opt[0] == 'D' &amp;&amp; cnt1){
            -- cnt1;
        }
        if(opt[0] == 'L' &amp;&amp; cnt1){
            s2[++ cnt2] = s1[cnt1];
            -- cnt1;
        }
        if(opt[0] == 'R' &amp;&amp; cnt2){
            s1[++ cnt1] = s2[cnt2];
            -- cnt2;
            sum[cnt1] = sum[cnt1 - 1] + s1[cnt1];
            f[cnt1] = max(f[cnt1 - 1] , sum[cnt1]);
        }
        if(opt[0] == 'Q'){
            scanf(&quot;%d&quot; , &amp;x);
            printf(&quot;%d\n&quot; , f[x]);
        }
    }

    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调栈]]></title>
        <id>https://functioncoder2006.github.io/post/dan-diao-zhan/</id>
        <link href="https://functioncoder2006.github.io/post/dan-diao-zhan/">
        </link>
        <updated>2021-12-31T08:11:47.000Z</updated>
        <content type="html"><![CDATA[<p>其实如果只看代码的话，和单调队列差不多，就是只是在一头操作而已</p>
<p>单调栈主要用来求 后面/前面 第一个比这个数 大/小 的数。就是及时把已经不可能成为最优解的值删掉</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 3e6 + 10;

int n , a[N] , Stack[N] , top;
int f[N];

inline int du(void){
    int x = 0 , f = 1;
    char ch = getchar();
    while(ch &gt; '9' || ch &lt; '0'){if(ch == '-')f = -1;ch = getchar();}
    while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
inline void write(int x){
    if(x &lt; 0){putchar('-');x = -x;}
    if(x &gt; 9)write(x / 10);
    putchar(x % 10 ^ 48);
    return;
}

int main(void){

    n = du();

    for(int i = 1 ; i &lt;= n ; ++ i){
        a[i] = du();
    }

    for(int i = n ; i &gt;= 1 ; -- i){
        while(top &amp;&amp; a[Stack[top]] &lt;= a[i])
            -- top;
        f[i] = Stack[top];
        Stack[++ top] = i;
    }

    for(int i = 1 ; i &lt;= n ; ++ i){
        write(f[i]) , putchar(' ');
    }

    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[归并排序求逆序对]]></title>
        <id>https://functioncoder2006.github.io/post/gui-bing-pai-xu-qiu-ni-xu-dui/</id>
        <link href="https://functioncoder2006.github.io/post/gui-bing-pai-xu-qiu-ni-xu-dui/">
        </link>
        <updated>2021-12-29T12:24:34.000Z</updated>
        <content type="html"><![CDATA[<p>首先我们先介绍一下归并排序</p>
<p>其实非常简单，将一个区间分成两个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l , mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[mid + 1 , r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，将这两个区间进行递归排序，然后尝试着将 这两个区间进行序列合并，合并成有序的序列</p>
<p>然后问我们考虑怎么求逆序对</p>
<p>对于一个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l , r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，我们可以将其分为两半，然后分别算出左半边逆序对个数和右半边逆序对个数，和跨过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> 分界线的逆序对数</p>
<p>左右半边很好处理，直接递归下去解决就可以</p>
<p>我们考虑跨过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> 的逆序对数怎么求</p>
<p>因为我们考虑的是跨过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> 的逆序对，因此与两半边各自的顺序无关（在左边就是在左边，在右边就是在右边）。此时，我们不妨考虑将每一半边都进行升序排序（这个归并排序顺便就可以完成，不需要消耗额外的复杂度），然后使用双指针算法</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 5e5 + 10;

int n , a[N] , b[N];
long long ans;

inline void merge(int l , int r){
    if(l == r)return;
    int mid = (l + r) &gt;&gt; 1;
    merge(l , mid); merge(mid + 1 , r);
    int i = l , j = mid + 1;
    for(int k = l ; k &lt;= r ; ++ k){
        if(j &gt; r || (i &lt;= mid &amp;&amp; a[i] &lt;= a[j]))
            b[k] = a[i] , ++ i;
        else b[k] = a[j] , ++ j , ans += (mid - i + 1);
    }
    for(int k = l ; k &lt;= r ; ++ k){
        a[k] = b[k];
    }
    return;
}

int main(void){
    
    scanf(&quot;%d&quot; , &amp;n);
    
    for(int i = 1 ; i &lt;= n ; ++ i){
        scanf(&quot;%d&quot; , &amp;a[i]);
    }
    
    merge(1 , n);
    
    printf(&quot;%lld&quot; , ans);
    
    return 0;
    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位运算]]></title>
        <id>https://functioncoder2006.github.io/post/ji-chu-suan-fa/</id>
        <link href="https://functioncoder2006.github.io/post/ji-chu-suan-fa/">
        </link>
        <updated>2021-12-29T08:49:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="位运算">位运算</h2>
<hr>
<h3 id="快速幂">快速幂</h3>
<p>基本思想就是<strong>任意一个正整数都可以唯一分解成若干个指数不重复的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的次幂之和</strong></p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup><mo>∗</mo><msup><mi>a</mi><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow></msup></mrow><annotation encoding="application/x-tex">a ^ b * a ^ c = a ^ {b + c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>因此我们考虑将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 二进制分解</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup><mo>=</mo><msup><mi>a</mi><msub><mi>k</mi><mn>1</mn></msub></msup><mo>∗</mo><msup><mi>a</mi><msub><mi>k</mi><mn>2</mn></msub></msup><mo>∗</mo><msup><mi>a</mi><msub><mi>k</mi><mn>3</mn></msub></msup></mrow><annotation encoding="application/x-tex">a ^ b = a ^ {k_1} * a ^ {k_2} * a ^ {k_3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">......</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的若干次幂</p>
<p>然后我们从低位到高位依次遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的二进制位，可以顺便递推得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><msub><mi>k</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">a ^ {k_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mi>i</mi></msup></msup><mo>=</mo><mo>(</mo><msup><mi>a</mi><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></msup><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a ^ {2 ^ i} = (a ^ {2 ^ {i - 1}}) ^ 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9944599999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944599999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9020857142857143em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24446em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944599999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9020857142857143em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>如果发现这个二进制位是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的话就累加到答案</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

int a , b , p;

long long power(int a , int b){
    long long ans = 1 , base = a;
    while(b){
        if(b &amp; 1)ans = (ans * base) % p;
        base = base * base % p;
        b &gt;&gt;= 1;
    }
    return ans % p;
}

int main(void){
    
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;
    
    cout &lt;&lt; power(a , b) &lt;&lt; endl;
    
    return 0;
    
}
</code></pre>
<p>学到了<strong>用右移运算遍历一个数的二进制位</strong></p>
<h3 id="龟速乘">龟速乘</h3>
<p>我们可以考虑使用和快速幂同样的思想，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 进行二进制拆分</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mo>(</mo><msup><mn>2</mn><msub><mi>k</mi><mn>1</mn></msub></msup><mo>+</mo><msup><mn>2</mn><msub><mi>k</mi><mn>2</mn></msub></msup><mo>+</mo><msup><mn>2</mn><msub><mi>k</mi><mn>3</mn></msub></msup><mo>+</mo><mo>…</mo><mo>…</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">a * b = a * (2 ^ {k_1} + 2 ^ {k_2} + 2 ^ {k _ 3} + ……)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mclose">)</span></span></span></span></p>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup><mo>=</mo><mi>a</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a * 2 ^ i = a * 2 ^ {i - 1} * 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>因此，我们很容易通过遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的二进制位，顺便递推求出每一项</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;
 
long long a , b , p;

long long power(long long a , long long b){
    a %= p , b %= p;
    long long ans = 0 , base = a;
    while(b){
        if(b &amp; 1)ans = (ans + base) % p;
        base = (base + base) % p;
        b &gt;&gt;= 1;
    }
    return ans % p;
}

int main(void){
    
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;
    
    cout &lt;&lt; power(a , b) &lt;&lt; endl;
    
    return 0;
    
}
</code></pre>
<h2 id="lowbit运算">lowbit运算</h2>
<h3 id="使用lowbit遍历二进制位">使用lowbit遍历二进制位</h3>
<pre><code class="language-cpp#include&lt;iostream&gt;">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

int n , h[1000000];

inline int lowbit(int x){
    return x &amp; (-x);
}

int main(void){

    cin &gt;&gt; n;

    for(int i = 0 ; i &lt;= 10 ; ++ i){
        h[1 &lt;&lt; i] = i;
    }

    while(n){
        cout &lt;&lt; h[lowbit(n)] &lt;&lt; endl;
        n -= lowbit(n) ;
    }

    return 0;

}

</code></pre>
<p>另外，二进制<strong>还有进行二进制运算时，各个二进制位互相独立</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zuma]]></title>
        <id>https://functioncoder2006.github.io/post/zuma/</id>
        <link href="https://functioncoder2006.github.io/post/zuma/">
        </link>
        <updated>2021-12-28T12:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>这道题告诉我们，<strong>很多题都是有关联的</strong></p>
<p>首先，通过读题看样例我们大致感受一下：一个区间，既可以分成两个区间进行消除；<strong>也可以先消除一个区间的几个子区间，最后形成最后一个回文，把它消除掉</strong></p>
<p>然后我们着重考虑第二种操作怎么做</p>
<p>我们发现，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub><mo>=</mo><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_l = a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，那么最后的结果可以等效成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{l + 1 , r - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。因为我们考虑将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和其他数字形成最后一个回文进行消除，而根据回文的性质，<strong>两边删除或添加相同的数字，结果已然是回文</strong></p>
<p>思路是哪里来的呢？其实就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>Q</mi><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">CQOI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span> 涂色那道题，考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub><mo>=</mo><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_l = a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的情况</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstring&gt;

using namespace std;

const int N = 510;

int n , a[N] , f[N][N];

int main(void){

    cin &gt;&gt; n;

    for(int i = 1 ; i &lt;= n ; ++ i){
        cin &gt;&gt; a[i];
    }

    memset(f , 0x3f , sizeof(f));

    for(int i = 1 ; i &lt;= n ; ++ i){
        f[i][i] = 1;
    }

    for(int i = 1 ; i &lt;= n ; ++ i){
        if(a[i] == a[i + 1]){
            f[i][i + 1] = 1;
        }
        else f[i][i + 1] = 2;
    }

    for(int Len = 3 ; Len &lt;= n ; ++ Len){
        for(int l = 1 ; l + Len - 1 &lt;= n ; ++ l){
            int r = l + Len - 1;
            if(a[l] == a[r])
                f[l][r] = min(f[l][r] , f[l + 1][r - 1]);
            for(int k = l ; k &lt; r ; ++ k){
                f[l][r] = min(f[l][r] , f[l][k] + f[k + 1][r]);
            }
        }
    }

    printf(&quot;%d&quot; , f[1][n]);

    return 0;

}
</code></pre>
<p>很多题目的操作和思想都是有一些相似和关联之处的，这就需要我们多多感受，多多思考</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Color]]></title>
        <id>https://functioncoder2006.github.io/post/color/</id>
        <link href="https://functioncoder2006.github.io/post/color/">
        </link>
        <updated>2021-12-27T13:41:32.000Z</updated>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/weixin_43359565/article/details/105464067?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.no_search_link</p>
]]></content>
    </entry>
</feed>